% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpbspline.R
\name{profile_loglik_gpbss}
\alias{profile_loglik_gpbss}
\title{Profile log-likelihood for GP-on-spline-coefficients model}
\usage{
profile_loglik_gpbss(
  psi,
  y,
  U,
  F,
  tau,
  R_fun,
  jitter = 1e-08,
  sigma2_df = c("n", "n-q"),
  return_details = FALSE
)
}
\arguments{
\item{psi}{Numeric vector of hyperparameters (passed to \code{R_fun}).}

\item{y}{Numeric response vector (length n).}

\item{U}{Numeric matrix (n x M) tensor-product spline basis (or any basis).}

\item{F}{Numeric matrix (n x q) mean/trend design (e.g., intercept-only or linear).}

\item{tau}{Nonnegative scalar noise-to-signal ratio. Noise variance is \eqn{\sigma^2\tau}.}

\item{R_fun}{Function taking \code{psi} and returning either:
(i) an MxM matrix \code{R}, or
(ii) a list with element \code{R} containing the MxM matrix.}

\item{jitter}{Nonnegative scalar jitter added to the diagonal of \eqn{\Sigma_0}
if needed for numerical stability.}

\item{sigma2_df}{Degrees-of-freedom divisor for \eqn{\hat\sigma^2}. Choose \code{"n"}
(default) to divide by n (MLE) or \code{"n-q"} to divide by n-q.}

\item{return_details}{Logical; if TRUE, returns \eqn{\hat\beta}, \eqn{\hat\sigma^2},
\eqn{\Sigma_0^{-1}} solves, etc.}
}
\value{
If \code{return_details=FALSE}: a single numeric value (profile logLik).
  If TRUE: a list with elements \code{logLik}, \code{beta_hat}, \code{sigma2_hat},
  \code{tau}, \code{psi}, and additional intermediates.
}
\description{
Computes the Gaussian profile log-likelihood for the model
\deqn{y = F\beta + U\gamma + \varepsilon, \quad
\gamma \sim N(0, \sigma^2 R(\psi)), \quad \varepsilon \sim N(0, \sigma^2 \tau I).}
}
\details{
For fixed hyperparameters \eqn{\psi} and \eqn{\tau}, the MLEs \eqn{\hat\beta} and
\eqn{\hat\sigma^2} are available in closed form via generalized least squares (GLS).
This function returns the *profile* log-likelihood after plugging these in.

NOTE: This implementation forms \eqn{\Sigma_0 = U R(\psi) U^\top + \tau I} explicitly
and uses a Cholesky factorization. That is correct but not scalable for large n/M.
}
\examples{
# Minimal R_fun: independent coefficients (R = I)
R_fun <- function(psi) diag(1, 10)
n <- 50; M <- 10
U <- matrix(rnorm(n*M), n, M)
F <- cbind(1)
y <- rnorm(n)
profile_loglik_gpbss(psi = numeric(0), y, U, F, tau = 0.1, R_fun = R_fun)

}
